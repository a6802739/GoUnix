========================================================================
不是main的其他包都被称为库,其他许多编程语言有着类似的概念。
当Go程序在执行的时候,首先调用的函数是main.main(),这是从 C 中继承而来。
========================================================================
查包的文档 1 godoc os | less 2 godoc os/exce | less
查包中的函数文档 godoc fmt Println | less
========================================================================
一个特殊的变量名是 _ （下划线），任何赋给它的值都被丢弃。
========================================================================
单词iota在日常英语短语not one iota，意思是不是最小，iota在枚举中使用
========================================================================
反引号`括住的字符串是不会进行转义的
========================================================================
rune是int32的别名，字符串一旦赋值给变量就不能修改，如果修改需要使用rune
转换成数组。Go有指针，但是没有指针运算，索引不能用指针变量遍历字符串的
各个字节。
========================================================================
Go有为了错误而存在的内建类型，叫error，error的值是nil。
通过用*前缀来定义一个指针，一个新定义的或者没有任何指向的指针，有值nil
在其他语言中，这经常被叫做空（NULL）指针，在Go中就是nil。
要让指针指向某些内容，可以使用取址操作符(&)。
========================================================================
& 按位与 | 按位或 ^ 按位异或 &^ 位清楚 ！ 逻辑非
========================================================================
Go有goto语句，用goto跳转到一定是当前函数内定义的标签，标签名是大小写敏
感的
========================================================================
Go的for循环有三种形式
for init; condition; post {}	<---和C的for一样
for condition {}		<---和while一样
for {}				<---和C的for(;;)一样（死循环）
========================================================================
利用break可以提前退出循环，break终止当前的循环
for i := 0; i < 10; i++ {
	if i > 5 {
		break	<---终止这个循环，只打印０到５
	｝
	println(i)
}
循环嵌套循环是，可以在break后指定标签，用标签决定那个循环被终止
J: for j := 0; j < 5; j++ {
	for i := 0; i < 10; i++ {
		if i > 5 {
			break J		<---终止的是j循环
		｝
		println(i)
	}
}
=======================================================================
array由[n]<type>定义，n标示array的长度，而<type>标示希望存储的内容的
类型。
var arr [10]int
arr[0] = 42
arr[1] = 13
注意：a := [3]int{1,2,3}可以简写为a := [...]int{1,2,3},Go会自动统计
元素的个数，注意，所有项目必须都指定。
=======================================================================
逆转字符串方法，从左边(i)至右(j)的交换字符
import "fmt"
func main() {
	s := "foobar"
	a := []byte(s)
	//Reverse a 
	for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
		a[i],a[j] = a[j],a[i]
	}
	fmt.Printf("%s\n",string(a))
}
=======================================================================
可以随意安排函数定义的顺序，编译器会在执行前扫描每个文件。
Go不允许函数嵌套，然而可以利用匿名函数实现它。
函数也是值。
=======================================================================
作用域
在Go中，定义在函数外的变量是全局的，那些定义在函数内部的变量，对于函数
来说是局部的。如果命名覆盖－－一个局部变量与一个全局变量有相同的名字－
－在函数执行的时候，局部变量将覆盖全局变量。
=======================================================================
type mytype int		<---新的类型
func (p mytype) funcname (q int) (r,s int) { return 0,0}
  |    |           |       |       |           |
  |    |           |       |       |           |
  |    |           |       |       |           --->函数体
  |    |           |       |       ---->函数的命名返回值
  |    |           |       ------->函数的输入参数
  |    |           ---------->函数的名字
  |    ------------------->函数的可定义特定类型，这类函数称为method
  ------------------------>保留字func定义一个函数
=======================================================================
函数的命名返回值
Go函数的返回值或者结果参数可以指定一个名字，名字不是强制的，但是它们
可以使得代码更加健壮和清晰，名字可以像原始的变量那样使用，就像输入参
数那样。如果对其命名，在函数开始时，它们会用其类型的零值初始化；如果
函数在不加参数的情况下执行return语句，结果参数的当前值会作为返回值返
回。用这个特性，允许用较少的代码做更多的事。
func ReadFull(r Reader, buf []byte) (n int,err error) {
	for len(buf) > 0 && err == nil {
		var nr int 
		nr, err = r.Read(buf)
		n += nr
		buf = buf[nr:len(buf)]
	}
	return
}
命名结果会被初始化并关联于无修饰的return
=======================================================================
defer 延迟的函数是按照后进先出(LIFO)顺序执行
=======================================================================
变参
接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数
使其接受变参　

func myfunc(arg ...int) {}

arg ...int　告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全
部是int。在函数体中，变量arg是一个int类型的slice

for _, n := range arg {
	fmt.Printf("And the number is: %d\n", n)
}

如果不指定变参的类型，默认是空的接口interface{}，下面演示向其传递变参

func myfunc(arg ...int) {
	myfunc2(arg...)		<---按原样传递
	myfunc2(arg[:2]...)	<---传递部分
}
========================================================================
函数也是值　函数可以回调
func callback(y int, f func(int)) {	<---f将会保存函数
	f(y)		<---调用回调函数f输入变量y
}
========================================================================
包的文档
每个包都应该有包注释，在package前的一个注释块。对于多文件包，包注释只
需要出现在一个文件前，任意一个文件都可以。通过package来定义引入包名，
包名可以和文件名不一样。包注释应当对包进行介绍，并提供相关于包的整体信
息。这会出现在godoc生成的关于包的页面上，并且相关的细节会一并显示。每
个定义（并且导出）的函数应当有一小段文字描述该函数的行为。
========================================================================
测试包
在Go中为包编写单元测试应当是一种习惯。编写测试需要包含testing包和程序
go test。go test程序调用了所有的测试函数。测试文件也在包目录中，被命
名*_test.go。这些测试文件同Go程序中的其他文件一样，但是go test只会执
行测试函数。
每个测试函数名字都有相同以Test开头的标识，func TestXxx(t *testing.T)
编写测试时，需要告诉go test测试是失败还是成功。测试成功则直接返回。当
测试失败可以用下面的函数标志。

func (t *T) Fail()
Fail标记测试函数失败，但仍然继续执行。
func (t *T) FailNow()
FailNow标记测试函数失败，并且中断其执行，当前文件的其他所有测试被跳过。
func (t * T) Log(args ...interface{})
Log用默认格式对其参数进行格式化，并且记录文本到错误日志。
func (t *T) Fatal(args ...interface{})
Fatal等价与Log()后跟随FailNow()。

在编写包的时候应当一边写代码，一边写（一些）文档和测试函数。
========================================================================
new分配；make初始化
new(T)返回*T指向一个零值T（指针）
make(T)返回初始化后的T
make仅适用于slice map和channel
========================================================================
一个接口就是定义，而方法就是实现。
单方法接口命名为方法名加上-er后缀:Reader Writer Formatter等。
========================================================================
并行是关于性能的；并发是关于程序设计的。
Go使用channel和goroutine开发并行程序的，goroutine是Go并发能力的核心。
goroutine简单的模型：它是与其他goroutine并行执行，有着相同地址空间的
函数。它是轻量的，仅比分配栈空间多一点点消耗，而初始时栈是很小的，所
以它们也是廉价的，并且随着需要在堆空间上分配（和释放）。
goroutine是一个普通的函数，只是需要使用保留字go作为开头。
ready("Tea",2)		<---普通函数调用
go ready("Tea",2)	<---ready()作为goroutine运行
--------------------------------------------------
func ready(w string,sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w,"is ready!")
}
func main() {
	go ready("Tea", 2)
	go ready("Coffee", 1)
	fmt.Println("I'm waiting")
	time.Sleep(5 * time.Second)　　<--移除后，程序立即终止，没有go
}
-------
I'm waiting		<---立刻
Coffee is ready!	<---1秒后
Tea is ready!		<---2秒后
------------------------------------------
同goroutine通讯机制是channels。channel可以与Unix　shell中的双向管道
做类比：可以通过他发送或者接受值。
定义一个channel时，需要定义发送到channel的值的类型，必须使用make。
ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
向channel发送或接受数据，是通过类似的操作符完成的： <-
ci <- 1		<---发送整数1到channel ci
<- ci		<---从channel ci接受整数
i := <-ci	<---从channel ci接受整数，并保存到i中
-----------------------------------------------------
var c chan int
func ready(w string, sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w, "is ready!")
	c <- 1
}
func main() {
	c = make(chan int)
	go ready("Tea",2)
	go ready("Coffee", 1)
	fmt.Println("I'm waiting, but not too long")
	<-c  //等待，直到从channel上接受一个值，注意，收到的值被丢弃
	<-c　　//两个goroutines，接受两个值
}
-------------------------------------------
通过select（和其他东西）可以监听channel上输入的数据，以便发送给go
L: for {
	select {
		case <- c:
			i++
			if i > 1 {
				break L
			}
		}
	}
------------------------------------------
ch := make(chan type, value) 
value == 0	无缓冲
value > 0	缓冲value的元素
---------------------------------------
关闭channel　检查channel是否被关闭
x, ok = <-ch
当ok被赋值为true意味着channel尚未被关闭，同时可以读取数据。否则ok被
赋值为false。在这个情况下表示channel被关闭。
=======================================================================
命令行参数
来自命令行的参数在程序中通过字符串slice os.Args获取，导入包os即可。
flag包有着精巧的接口，同样提供了解析标识的方法。
dnssec := flag.Bool("dnssec",false,"Request DNSSEC records")
port := flag.String("port","53","Set the query port")
flag.Usage = func() {
	fmt.Fprintf(os.Stderr,"Usage: %s [OPTIONS] [name ...]\n",os.Args[0])
	flag.PrintDefaults()
}
flag.Parse()
=======================================================================
执行命令
os/exec包有函数可以执行外部命令，这也是在Go中主要的执行命令的方法。
通过定义一个有着数个方法的*exec.Cmd结构来使用。
执行ls -l
import "os/exec"
cmd := exec.Command("/bin/ls","-l")
err := cmd.Run()
从命令行的标准输出中获得信息
import "exec"
cmd := exec.Command("/bin/ls","-l")
buf, err := cmd.Output()	<---buf是一个[]byte
========================================================================
网络
所有网络相关的类型和函数可以在net包中找到。这其中最重要的函数是Dial。
当Dial到远程系统，这个函数返回Conn接口类型，可以用于发送或接受信息。
函数Dial简洁的抽象了网络层和传输层。因此IPv4或者IPv6，TCP或者UDP可以
公用一个接口。
========================================================================
