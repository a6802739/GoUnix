==============================================================================
Lex(Lexical Analyzar)词汇分析  Yacc(Yet Another Compiler Compiler)另一个编译器
Lex的GUN版本为flex  Yacc的GUN版本为bison
Lex主要是定义词汇,而Yacc则是根据Lex定义的词汇执行Yacc中相应的动作,即语法解析器
------------------------------------------------------------------------------
Lex是一种生成扫描器的工具.扫描器是一种识别文本中的词汇模式的程序.
当Lex接受到文件或文本形式的输入时,他试图将文本与常规表达式进行匹配.
一次读入一个输入字符,直到找到一个匹配模式.如果能找到一个匹配模式,Lex就执行相关
的动作(可能包括返回一个标记).如果没有可以匹配的常规表达式,将会停止进一步处理,
Lex将显示一个错误消息.
-------------
Lex编程3步:
1以Lex可以理解的格式指定模式相关的动作.
2在这一文件上运行Lex,生成扫描器的C代码.
3编译和链接C代码,生成可执行的扫描器.(使用yacc生成扫描器)
-------------------
Lex程序分为三个段:
第一段是C和Lex的全局声明.
第二段包括模式匹配规则(C代码).
第三段是补充的C函数.(一般都有main()函数)
#这些段以%%来分界.
------------------
#一个字数统计Lex程序示例
第一段:
%{
	int wordCount = 0;
%}
chars [A-Za-z\_\'\.\"]
numbers ([0-9])+
delim [" "\n\t]
whitespace {delim}+
words {chars}+
%%
#这两个百分号标记指出了Lex程序中第一段的结束和第二段的开始.
第二段:
{words} {
wordCount++;
/* increase the word count by one */
}
{whitespace} {
/* do nothing */
}
{numbers} {
/* one may want to add some processing here */
}
%%
第三段:
void main() {
	yylex();/*start the analysis*/
	printf(" No of words:%d\n",wordCount);
}
int yywrap() {
	return 1;
}
#这一段必须包括yywrap()函数.
#Lex有一套可供使用的函数和变量.
-------------------------------
Lex有几个函数和变量提供了不同的信息,可以用来编译实现复杂函数的程序.
这些变量和函数都是以yy开头,其实是yacc定义的相关执行动作在lex中调用了.

Lex变量:
------------------------------------------------------------------------------
yyin		FILE*类型.他指向lexer正在解析的当前文件.
------------------------------------------------------------------------------
yyout		FILE*类型.他执行记录lexer输出的位置.
		缺省下yyin和yyout指向标准输入和输出.
------------------------------------------------------------------------------
yytext		匹配模式的文本额存储在这一变量中(char*).
------------------------------------------------------------------------------
yyleng		给出匹配模式的长度.
------------------------------------------------------------------------------
yylineno	提供当前的行数信息
------------------------------------------------------------------------------

Lex函数:
------------------------------------------------------------------------------
yylex()		这个函数开始分析.他有Lex自动生成.
------------------------------------------------------------------------------
yywrap()	这个函数在文件(或输入)的末尾调用.如果函数的返回值是1,就停止解
		析.使用该函数放在第三段中可以解析多个文件.方法是使用yyin文件指
		针指向不同的文件,知道所有的文件都被解析.最后,yywrap()可以返回1
		来表示解析的结束.
------------------------------------------------------------------------------
yyless(int n)	这个函数可以用来送回除了前n个字符外的所有读出标记.
------------------------------------------------------------------------------
yymore()	这一函数告诉Lexer将下一个标记附加到当前标记后.
------------------------------------------------------------------------------

------------------------------------------------------------------------------
Yacc将任何一种编程语言的所有语法翻译成针对此种语言的Yacc语法解析器.
Yacc用巴克斯范式(BNF)来书写.
----------------------
Yacc生成一个解析器:
  *编写一个.y的语法文件(同时说明C在这里要进行的动作).
  *编写一个词法分析器(lex)来处理输入并将标记传递给解析器.(使用lex来完成)
  *编写一个函数,通过调用yyparse()来开始解析.
  *编写错误处理历程(如yyerror()).
----------------
一个编译器工作流程:
1源代码(source code).
2用lex分析源代码标记token,生成词法分析器的可执行程序(C程序).
3用yacc根据lex分析的token来执行相应的动作,即解析器.
4编译yacc生成的代码以及其它相关的源文件.
5将源代码链接到适当的可执行解析器库.
---------------------------------------
Yacc的编写语法和Lex编写语法类似也用%%分为三段.分别是:声明 语法规则 C代码.
类似与Lex,Yacc也有一套变量和函数可供用户来进行功能扩展.
如,YYSTYPE定义了用来将值从lexer拷贝到解析器或Yacc的yylval(一个yacc变量)的类型.
Yacc程序:
第二段:
动作解析语法
token: action {
	/* action to be taken in C */
};
文件解析语法
file: exec file
	| exec;
	exec: action {
		/* action to be taken in C */
	};
第三段:
void main() {
	yyparse();
}
int yyerror(char* msg) {
		printf("Error:%s\n",msg);
}
#一个函数如main()调用yyparse()函数如lex的yylex()等效函数.
#yacc提供yyerror(char msg)函数代码.
#当解析器遇到错误时调用yyerror(char msg)
==============================================================================
==============================================================================
