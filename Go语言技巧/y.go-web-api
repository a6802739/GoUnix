==============================================================================
io/ioutil
=========

package main

import (
	"fmt"
	"io/ioutil"
)
//数据结构
type Page struct {
	Title	string
	Body	[]byte
}

func (p *Page) save() error {
	filename := p.Title + ".txt"
	return ioutil.WriteFile(filename,p.Body,0600)
}

func loadPage(title string) (*Page,error) {
	filename := title + ".txt"
	body, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	return &Page{Title:title,Body:body},nil
}

func main() {
	p1 := &Page{Title:"TestPage",Body:[]byte("This is a sample Page.")}
	p1.save()
	p2,_ := loadPage("TestPage")
	fmt.Println(string(p2.Body))
}
这个实例主要是为了演示将Web的页面抽象成相应的数据结构及ioutil包对文件的操作
==============================================================================
net/http
========

package main

import (
	"fmt"
	"net/http"
)

//请求执行的动作
func handler(w http.ResponseWriter,r *http.request) {
	fmt.Fprintf(w, "Hi there,I love %s!",r.URL.Path[1:])
}

func main() {
	//路由到/并执行相应的动作
	http.HandleFunc("/",handler)
	http.ListenAndServe(":8080",nil)
}
//使用net/http包
-----------------------------------------
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

//执行相应的动作
func viewHandler(w http.ResponseWriter,r *http.Request) {
	title := r.URL.Path[len("/view/"):]
	p,_ := loadPage(title)
	fmt.Fprintf(w,"<h1>%s</h1><div>%s</div>",p.Title,p.Body)
}

func main() {
	//路由到/view/并执行viewHandler动作
	http.HandleFunc("/view/",viewHandler)
	http.ListenAndServe(":8080",nil)
}
//使用io/ioutil和net/http包
=============================================================================
html/template io/ioutil net/http
================================
package main

import (
	"html/template"  //替代fmt用HTML模板渲染输出
	"io/ioutil"
	"net/http"
)

//数据结构
type Page struct {
	Title	string
	Body 	[]byte
}

//保存文件
func (p *Page) save() error {
	filename := p.Title + ".txt"
	return ioutil.WriteFile(filename,p.Body,0600)
}

//加载文件
func loadPage(title string) (*Page,error) {
	filename := title + ".txt"
	body,err := ioutil.ReadFile(filename)
	if err != nil {
		return nil,err
	}
	return &Page{Title:title,Body:body},nil
}

//渲染模板
func renderTemplate(w http.ResponseWriter,tmpl string,p *Page) {
	t,_ := template.ParseFiles(tmpl + ".html")
	t.Execute(w,p)
}

//执行路由/view/动作viewHandler
func viewHandler(w http.ResponseWriter,r *http.Request) {
	title := r.URL.Path[len("/view/"):]
	p,_ := loadPage(title)
	renderTemplate(w,"view",p)
}

//执行路由/edit/动作editHandler
func editHandler(w http.ResponseWriter,r *http.Request) {
	title := r.URL.Path[len("/edit/"):]
	p,err := loadPage(title)
	if err != nil {
		p = &Page{Title:title}
	}
	renderTemplate(w, "edit",p)
}

func main() {
	http.HandleFunc("/view/",viewHandler)
	http.HandleFunc("/edit/",editHandler)

	http.ListenAndServe(":8080",nil)
}
----------------
处理不存在的网页
----------------
func viewHandler(w http.ResponseWriter, r *http.Request) {
	title := r.URL.Path[len("/view/"):]
	p, err := loadPage(title)
	if err != nil {
		//网页重定向
		http.Redirect(w,r,"/edit/"+title,http.StatusFound)
		return
	}
	renderTemplate(w,"view",p)
}
//http.StatusFound HTTP302状态码
----------------
保存修改过的表单
----------------
func saveHandler(w http.ResponseWriter, r *http.Request) {
	title := r.URL.Path[len("/save/"):]
	body := r.FormValue("body")
	p := &Page{Title:title,Body:[]byte(body)}
	p.save()
	http.Redirect(w,r,"/view/"+title,http.StatusFound)
}
--------
错误处理
--------
func renderTemplate(w http.ResponseWriter, tmpl string,p *Page) {
	t, err := template.ParseFiles(tmpl + ".html")
	//网页中的错误处理
	if err != nil {
		http.Error(w,err.Error(),http.StatusInternalServerError)
		return
	}
	err = t.Execute(w,p)
	//网页中的错误处理
	if err != nil {
		http.Error(w,err.Error(),http.StatusInternalServerError)
	}
}

func saveHandler(w http.ResponseWriter,r *http.Request) {
	title := r.URL.Path[len("/save/"):]
	body := r.FormValue("body")
	p := &Page{Title:title,Body:[]byte(body)}
	err := p.save()
	if err != nil {
		http.Error(w,err.Error(),http.StatusInternalServerError)
		return
	}
	http.Redirect(w,r,"/view/"+title,http.StatusFound)
}
--------
模板缓存
--------
edit.html

<h1>Editing {{.Title}}</h1>
<form action="/save/{{.Title}}" method="POST">
<div><textarea name="body" rows="20" cols="80">{{printf "%s" .Body}}</textarea></div>
<div><input type="submit" value="Save"></div>
</form>

view.html

<h1>{{.Title}}</h1>
<p>[<a href="/edit/{{.Title}}">edit</a>]
<div>{{prinft "%s" .Body}}</div>

//上面的方法是每解析一个文件就需要加载和渲染一次,这样会浪费时间
//我们可以通过一次将多个文件都解析为可引用的单一的*Template,然后通过使用这个方
//法ExecuteTemplate渲染成为一个特定的模板.
//这样在我们添加新的模板的时候就比较的方便了.只用添加模板的名字,或将模板整合.

var templates = template.Must(template.ParseFiles("edit.html","view.html"))

func renderTemplate(w http.ResponseWriter,tmpl string,p *Page) {
	err := templates.ExecuteTemplate(w, tmpl+".html",p)
	if err != nil {
		http.Error(w,err.Error(),http.StatusInternalServerError)
	}
}
==============================================================================
验证(Validation)
================
//当用户提供一个随意的路径在服务器上进行读写的话,这明显是一个严重的安全漏洞,
//如普通用户获得了管理员的url资源,为了避免这个发生,需要使用一个正则表达式来验
//证提交的url资源.

import regexp

var validPath = regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")

func getTitle(w http.ResponseWriter,r *http.Request)(string, error) {
	m := validPath.FindStringSubmatch(r.URL.Path)
	if m == nil {
		http.NotFound(w,r)
		return "",errors.New("Invalid Page Title")
	}
	return m[2],nil //Titl是第二个子表达式
}
-------------每个动作都需要验证一下--------------

func viewHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, "/edit/"+title, http.StatusFound)
        return
    }
    renderTemplate(w, "view", p)
}

func editHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        p = &Page{Title: title}
    }
    renderTemplate(w, "edit", p)
}

func saveHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    body := r.FormValue("body")
    p := &Page{Title: title, Body: []byte(body)}
    err = p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, "/view/"+title, http.StatusFound)
}
==============================================================================
函数闭包
========
//上面的每个动作函数都需要进行url验证和错误检查,这让代码重复了很多.
//我们需要将url验证和错误检查封装进入一个函数中统一调用,这样看起来就会更简洁.
//函数文字相当于一个匿名函数,如
//f := func(x,y int) int { return x + y }

//首先,我们需要重新定义每一个执行动作的函数,让其接受三个参数,多了一个title.
func viewHandler(w http.ResponseWriter,r *http.Request,title string)
func editHandler(w http.ResponseWriter,r *http.Request,title string)
func saveHandler(w http.ResponseWriter,r *http.Request,title string)

//现在定义一个上面类型函数的包裹函数,并且返回一个http.HandlerFunc类型的函数,
//这个返回类型(http.HandlerFunc类型函数)适合传递给函数http.HandleFunc.
func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
	return func(w http.ResponseWriter,r *http.Request) {
		//valition(验证)
		//error(验证里的错误检查)
		//fn(调用函数自身)
	}
}
------------------------------
func makeHandler(fn func(http.ResponseWriter, *http.Request,string)) http.HandlerFunc {
	return func(w http.ResponseWriter,r *http.Request) {
		m := validPath.FindStringSubmatch(r.URL.Path)
		if m == nil {
			http.NotFound(w,r)
			return
		}
		fn(w,r,m[2])
	}
}

func main() {
	http.HandleFunc("/view/",makeHandler(viewHandler))
	http.HandleFunc("/edit/",makeHandler(editHandler))
	http.HandleFunc("/save/",makeHandler(saveHandler))

	http.ListenAndServe(":8080",nil)
}
-------------------------final code--------------------------
package main

import (
	"html/template"
	"io/ioutil"
	"net/http"
	"regexp"
)

type Page struct {
	Title string
	Body  []byte
}

func (p *Page) save() error {
	filename := p.Title + ".txt"
	return ioutil.WriteFile(filename, p.Body, 0600)
}

func loadPage(title string) (*Page, error) {
	filename := title + ".txt"
	body, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	return &Page{Title: title, Body: body}, nil
}

//移除了验证及验证的错误检查后的动作执行
func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
	p, err := loadPage(title)
	if err != nil {
		http.Redirect(w, r, "/edit/"+title, http.StatusFound)
		return
	}
	renderTemplate(w, "view", p)
}

//移除了验证及验证的错误检查后的动作执行
func editHandler(w http.ResponseWriter, r *http.Request, title string) {
	p, err := loadPage(title)
	if err != nil {
		p = &Page{Title: title}
	}
	renderTemplate(w, "edit", p)
}

//移除了验证及验证的错误检查后的动作执行
func saveHandler(w http.ResponseWriter, r *http.Request, title string) {
	body := r.FormValue("body")
	p := &Page{Title: title, Body: []byte(body)}
	err := p.save()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	http.Redirect(w, r, "/view/"+title, http.StatusFound)
}

//一次多个文件的模板解析
var templates = template.Must(template.ParseFiles("edit.html", "view.html"))

//渲染模板
func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
	err := templates.ExecuteTemplate(w, tmpl+".html", p)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

//正则表达式的验证变量
var validPath = regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")

//验证以验证错误检查的集体执行动作的封装(闭包 匿名函数)
func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		m := validPath.FindStringSubmatch(r.URL.Path)
		if m == nil {
			http.NotFound(w, r)
			return
		}
		fn(w, r, m[2])	//注意自身的调用
	}
}

func main() {
	http.HandleFunc("/view/", makeHandler(viewHandler))
	http.HandleFunc("/edit/", makeHandler(editHandler))
	http.HandleFunc("/save/", makeHandler(saveHandler))

	http.ListenAndServe(":8080", nil)
}
==============================================================================
==============================================================================
