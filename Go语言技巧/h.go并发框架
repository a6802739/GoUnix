=============================================================================
并发模式
========

------------------------------协程--------------------------->
              |                               ^
              |通道                           |通道
              |                               |
              >                               |
------------------------------协程--------------------------->

通道在协程之间传输数据，通道在众多协程之间传递的数据可以是值也可以是引用
协程可以向通道放入数据，如果通道满了，会挂起协程，直到通道可以放入数据为止
协程可以向通道索取数据，如果通道无数据，会挂起协程，直到通道返回数据为止
类似与事件驱动和阻塞队列
=============================================================================
并发模式的生成器
================

-----------------------------主协程-------------------------->
            |                  ^                ^
            |创建协程　　　　　|数据            |数据
　　　　　  |                  |                |
          　>---------------生成器协程----------------------->

有时候，需要有一个函数能不断生成数据。比如这个函数可以读文件，读网络，生成自
增长序列，生成随机数，生成ID，做一个定时器。这些行为的特点就是，函数的已知一
些变量，如文件路径。然后不断调用，返回新的数据。
=============================================================================
并发模式生成器的多路复用
========================

------------------------------输入协程甲------------------------------->
                                                      |
---------------输入协程乙-------------->              |
     |数据　　　　　　　　|数据                       |数据
     >                    >                           >
--------------------------多路复用协程（组）--------------------------->
     |                          |                      |
     |数据                      |数据                  |数据
     >                          >                      >
------------------------------输出协程--------------------------------->

调用生成器，可以返回一个“服务”，启动若干生成器，再将其整合成一个大的服务。可
用在持续获取数据的场合，用途广泛，如读取数据，生成ID，甚至定时器。
多路复用是一次处理多个队列的技术。多路复用可以将若干个相似的小服务整合成一个
大服务。
Go语言通过提供了select关键字来监听解决众多协程争抢输出的通道，加大输出通道的
缓冲大小也是个通用的解决方法。
=============================================================================
并发模式的参数池
================

              |                 |
              |参数一           |参数二
              >                 >
     >--------------执行协程----------------->
     |                                       |
     |创建协程                               |执行结果
     |                                       >
---------------------------调用协程--------------------------->

在使用协程的时候，创建一个协程，返回一个执行结果池的地址，之后可以通过它等带
结果，同样也可以将参数的获得用同样的方式，就像一直检测参数池和结果池有没有需
要的数据一样。
调用一个函数的时候，往往是参数已经准备好了，调用协程的时候也同样如此，但是如
果我们将传入的参数设为通道，这样就可以在不准备好参数的情况下调用函数，函数调
用和函数参数准备这两个过程可以完全解耦。这也可以应用在数据库的访问上。
参数池和生成器的区别在于，参数池返回一个结果，而生成器可以重复调用。还有就是
将参数channel和结果channel定义在一个结构体里面作为参数，而不返回结果channel。
这样可以增加聚合度，好处就是可以和多路复用技术结合起来使用。
池子特点就是可以在调用的时候不关心数据是否准备好，返回值是否计算好的问题，让
程序中的组件在准备好数据的时候自动跑起来。
=============================================================================
并发循环
========

     -----------循环体协程---------->
     ^    ----------循环体协程---------------->
     |    ^    ---------循环体协程----->       |
     |    |    ^                               |
     |    |    |创建协程                       |循环结束
     |    |    |                               >
-------------------------调用协程----------------------------->

循环体往往在时间上不可控，如果让循环体并发执行，那么性能就会提高很多。
在每个循环体内部启动协程，协程作为循环体可以并发执行，调用启动前设置一个计数
器，每一个循环体执行完毕就在计数器上加一个元素，调用完成后通过监听计数器等待
循环协程全部完成。
=============================================================================
并发的管道过滤
==============

-----------------生成器协程--------------------->
         |
 原始数据|    @----->@------>@
         |   ^　　　　　　　　\
         |  /                  \中间数据
         | /　　　　　　　　　　\
         >@ 过滤协程             @ 过滤协程
                                /
                               /
                     @<------@<
                     |
                     |结果数据
                     >
---------------结果处理协程--------------------->

将参数池和结果池首尾相连就形成了过滤协程（filter），多个过滤协程连在一起，就
形成了并发的管道过滤（pipe filter）。这样做的好处就是每个通道（channel）只有
两个协程访问，就不会有激烈的竞争，性能会比较好。
=============================================================================
超时提醒
========

          ---------定时器--------->
          ^                        |
          |创建协程                |
          |                        >
-------------------主协程---------------------->

对于协程想从一个通道读数据，但无人往这个通道写入数据这种情况。解决的办法就是
加入超时机制。对于有不确定会不会返回的情况，必须加入超时，避免出现永久等待。
另外不一定要使用定时器才能终止协程。也可以对外暴露一个退出提醒通道。任何其他
协程都可以通过该通道来提醒这个协程终止。
=============================================================================
=============================================================================
