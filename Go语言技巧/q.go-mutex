==============================================================================
互斥锁(sync.Mutex{})  读写锁(sync.RWMutex{})  组等待(sync.WaitGroup{})
条件变量(sync.Cond{}/sync.NewCond)  原子操作(sync.Atomic())
执行一次(sync.Onec()  临时对象池(sync.Pool())
==============================================================================
互斥锁
------
可以使用原子操作来管理简单的计数器，即多个协程对同一个值进行计数使用的是原子的
简单操作。但对于更加复杂的情况，可以使用一个互斥锁来在Go协程间安全的访问数据。
sync.Mutex{}
sync.Mutex{}.Lock() 确保独占访问
sync.Mutex{}.Unlock() 解除独占访问
-----------------------------------
var mutex sync.Mutex

func write() {
	mutex.Lock()
	defer mutex.Unlock() 
	.....
	.....
}
------------------------------------
package main

import (
	"fmt"
	"math/rand"
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

func main() {
	
	var state = make(map[int]int)

	var mutex = &sync.Mutex{}

	var ops int64 = 0

	
	//运行100个Go协程来重复读取state
	for r := 0; r < 100; r++ {
		go func() {
			total := 0
			for {
				key:=rand.Intn(5)
				mutex.Lock()	//确保对state的独占访问
				total+=state[key]
				mutex.Unlock()	//解除对state的独占访问
				atomic.AddInt64(&ops,1)

				//为了确保这个Go协程不会在调度中饿死，需在每次
				//操作后明确的使用runtime.Gosched()进行释放。
				runtime.Gosched()
			}
		}{}
	}


	//===============================================
	//同样，运行10个Go协程来模拟写入操作，使用和读取相同的模式。
	for w := 0; w < 10; w++ {
		go func() {
			for {
				key := rand.Intn(5)
				val := rand.Intn(100)
				mutex.Lock()
				state[key] = val
				mutex.Unlock()
				atomic.AddInt64(&ops,1)
				runtime.Gosched()
			}
		}()
	}

	//让100个读协程和10个写协程对state和mutex的操作运行1s。
	time.Sleep(time.Second)

	//获取最终的操作计数
	opsFinal := atomic.LoadInt64(&ops)
	fmt.Println("ops:",opsFinal)

	//对state使用一个最终的锁，显示最终的结果。
	mutex.Lock()
	fmt.Println("state:",state)
	mutex.Unlock()
}
==============================================================================
读写锁
------
读写锁是针对对读写操作的互斥锁.它与普通的互斥锁最大的不同就是,它可以分别针对读
操作和写操作进行锁定和解锁操作.读写锁遵循的访问控制规则与互斥锁有所不同.在读写
锁管辖的范围内,它允许任意个读操作任意个读操作同时进行.但是,在同一时刻,它只允许
有一个写操作在进行.并且,在某一个写操作被进行的过程中,读操作的进行也是不被允许
的.也就是说,读写锁控制下的多个写操作之间都是互斥的,并且写操作与读操作之间也都
是互斥的.但是,多个读操作之间却不存在互斥关系.
读写锁可以在降低因使用锁而对程序性能造成的损耗情况下完成对共享资源的访问控制.
---------------
sync.RWMutex{}
sync.RWMutex{}.Lock()
sync.RWMutex{}.Unlock()
//这两个方法分别代表了对写操作的锁定和解锁
sync.RWMutex{}.RLock()
sync.RWMutex{}.RUnlock()
//这两个方法分别表示了对读操作的锁定和解锁
sync.RWMutex{}.RLocker()
这个RLocker方法会返回一个实现了sync.Locker接口的值.sync.Locker接口类型包含了两
个方法:Lock和Unlock.其实,*sync.Mutex类型和*sync.RWMutex类型都是该接口类型的实
现类型而在调用*sync.RWMutex类型值的RLocker方法之后所得到的结果值就是这个值本身.
只不过,这个结果值的Lock方法和Unlock方法分别对应了针对该读写锁的读锁定操作和读
解锁操作.
==============================================================================
组等待
------
sync.WaitGroup{}
sync.WaitGroup{}.Add()
sync.WaitGroup{}.Done()
sync.WaitGroup{}.Wait()
类型sync.WaitGroup是一个结构体类型.在其中有一个代表计数的字段.当sync.WaitGroup
类型的变量被声明之后,其值中的那个计数值将会是0.
Add()方法可以增大或减少其中的计数值.
Done()方法使其中的计数值减一.
----------------
var wg sync.WaitGroup
wg.Add(6)
wg.Add(-3) //与三个Done()等价
wg.Done()
wg.Done()
wg.Done()
-------------
虽然Add()可接受负值,Done()可以减值,但是不要将计数值变为负数,因为这样会立即引发
一个运行恐慌.
---------------
Wait()方法的调用是来检查计数值的.如果这个计数值为0.那么该方法会立即返回,且不会
对程序的运行产生任何影响.但是,如果这个计数值大于0,那么该方法调用方的Goroutine
就会被阻塞.知道该计数值重新变为0时,被阻塞的Goroutine才会被唤醒.
这个类型的值一般备用来协调多个Goroutine的运行.假设,在我们的程序中启用了4个协程,
分别是G1,G2,G3和G4.其中,G2,G3和G4是由G1中的代码启用并被用于执行某些特定任务的.
G1在启用这3个Goroutine之后要等待这些特定任务的完成,这时该方法就比较适合.
-----------------
var wg sync.WaitGroup
wg.Add(3)

go func() { //G2
	.....
	.....
	wg.Done()
}()

go func() { //G3
	....
	....
	wg.Done()
}()

go func() { //G4
	....
	....
	wg.Done
}()

wg.Wait()
fmt.Println("G2,G3 and G4 are ended.")
==============================================================================
条件变量
--------
sync.Cond{}
sync.Cond{}.Wati()
sync.Cond{}.Signal()
sync.Cond{}.Broadcast()
sync.NewCond()
在Go语言中,sync.Cond类型代表了条件变量.与互斥锁和读写锁不同,简单的声明无法创建
出一个可用的条件变量.为了得到这样一个条件变量,需要用到sync.NewCond函数.
---------------------------------------
该函数声明:func Newcond(l Locker) *Cond
---------------------------------------
sync.NewCond函数的唯一参数是sync.Locker类型的,而具体的参数值既可以是一个互斥锁
也可以是一个读写锁.该函数的返回一个*sync.Cond类型的结果值.
类型*sync.Cond的方法集合中有3个方法,即Wait方法,Signal方法和Broadcast方法.分别
代表了等待通知,单发通知和广播通知的操作.
Wait方法是接受通知解锁自己持有的锁,并阻塞接受的Goroutine.
Signal和BroadCast的作用都是发送通知以唤醒正在为此而被阻塞的Goroutine.不同的是,
前者的目标只有一个,而后者的目标则是所有.
==============================================================================
原子操作
--------
sync.atomic()
原子操作即是进行过程中不能被中断的操作.原子操作仅会由一个独立的CPU指令代表和完
成.只有这样才能够在并发环境下保证原子操作的绝对安全.
对于一个不能被取址的数值是无法进行原子操作的.
在进行读取值的操作的过程中,其它对此值的读写操作是可以被同时进行的.它们并不会受
到任何限制.例如在32位计算架构的计算机上写入一个64位的整数.如果在这个写操作未完
成的时候,有一个读操作被并发地进行了,那么这个读操作很可能会读取到一个只被修改了
一般的数据.
在对值的读取和写入的操作实际上对应了原子操作的载入和存储.
------------------------------------------------------------------------------
原子操作的类型有int32,int64,uint32,uint64,uintptr和unsafe.Pointer共6个类型.
1增或减 Addint32 Addint64 Adduint32 Adduint64 Adduintptr
2比较并交换(Compare And Swap) 先判断参数addr指向的被操作值与参数old的值是否相
等.仅当此判断得到肯定的结果之后,该函数才会用参数new代表的新值替换掉原先的旧值.
否则,后面的替换操作就会被忽略.
3交换(Swap) 与比较并交换的操作不同,原子交换操作不会关心被操作值的旧值.它会直接
设置新值.但作为交换,它会返回被操作值的旧值.
4载入(Load) LoadInt32 LoadInt64 LoadPointer LoadUint32 LoadUint64 LoadUintptr
5存储(Store) 
==============================================================================
只执行一次
----------
sync.Once{}
sync.Once{}.Do()
--------------------
var once sync.Once
once.Do(func() { fmt.Println("Once!") })
------------------------------------------
方法Do可以接受一个无参数,无结果的函数值作为参数.该方法一旦被调用,就会调用被作
为参数传入的那个参数.
对于一个sync.Once类型值的指针方法Do的有效调用次数永远会是1.也就是说,无论调用这
个方法多少次,也无论我们在多次调用时传递给它的参数值是否相同,都仅有第一次调用是
有效的.
==============================================================================
临时对象池
----------
sync.Pool{}
sync.Pool{}.Get()
sync.Pool{}.Put()
-----------------
sync.Pool类型值看作是存放可被重复使用的值的容器.此类容器是自动伸缩的,高效的,同
时也是并发安全的.
sync.Pool{}的结构体中有一个唯一的公开字段New.该字段的类型为func() interface{}.
通过给字段New的函数临时对象池来创建对象值.
Get方法是从池中获取一个interface{}类型的值.
Put方法是把一个interface{}类型的值放置与池中.
如果池子中没有任何对象,Get方法返回的值为nil.如果有的话就会在该方法返回它之前就
一定会把它从池中删除掉.
临时对象池的突出特性是对垃圾回收友好.垃圾回收的执行一般会使临时对象池中的对象
值被全部移除.也就是说,即使不使用Get方法将其取走,也不会永远待在那里,他的生命周
期取决于垃圾回收任务下一次的执行时间.
---------------------------------------
使用场景:作为临时且状态无关的数据的暂存处.
不适用场景:用来存放数据库连接的实例.
==============================================================================
==============================================================================
