==============================================================================

kubernetes简介


kubernetes为容器化应用提供资源调度,部署,服务发现,扩展机制等功能.
kubernetes可以被部署在物理集群和各类云环境中.

 使用Docker对应用进行打包,实例化和运行.
 以集群的方式运行和管理跨主机的容器.
 解决跨主机容器的通信问题.
 提供自我修复功能,保证系统运行的健壮性.

==============================================================================

kubernetes核心


kubernetes的核心包括节点(Node),Pod,服务(Service),卷(Volume),标签(Label)和备份
控制器(Replication Controller).

--------------------------------------

节点:


节点是kubernetes系统中的一台工作机器,常被称为Minion,他可以是物理机,也可以是虚
拟机.每一个节点都包含Pod运行所需的必要服务,如Docker,kuberlet和网络代理(proxy).
节点受kubernetes系统中的主节点控制.节点本身并不属于kubernetes的概念,他是云平台
中的虚拟机或者实体机.所以,当一个节点加入到kubernetes系统中时,他将会创建一个数
据结构来记录该节点的信息.只有通过验证的节点才能够加入到kubernetes系统中最终成
为kubernetes的节点.


节点的两种管理方式:节点管理器(Node Controller)和通过命令手动管理.


节点管理器:

它是kubernetes主控节点上管理集群节点的组件,主要包含两个功能:集群节点的同步和单
个节点生命周期的管理.当有节点加入到kubernetes中时,节点管理器将会创建节点信息;
当有节点需要从kubernetes中删除时,节点管理器则会删除该节点的节点信息.需要注意的
是,节点管理器仅仅创建节点的元数据,用于跟踪节点的状态,节点上的服务需要用户自己
安装.

手动管理节点:

kubernetes的管理员可以通过kubectl命令来管理节点.
使用kubectl命令创建和删除节点时,也只是删除节点的配置信息.

-----------------------------------------------------------

Pod


在kubernetes中,Pod是最小的可创建,调度和管理的部署单元.它是容器化环境中的"逻辑
主机",可以包含一个或多个有关联的容器,并且容器之间可以共享数据卷.
容器存在于Pod之中,而Pod又存在于节点之中.

例如:
一个Web站点应用由前端,后端和数据库组成,这三个组件运行的各自的容器中,可以创建包
含这三个容器的Pod.

为什么需要抽象出Pod这个概念?

1 资源共享和通信:同一Pod中的容器拥有相同的网络命名空间,IP地址和端口区间,它们之
间可以直接用localhost来发现和通信.在无层次的共享网络中,每个Pod都有一个IP地址,
用于跟其它物理主机和容器进行通信,Pod的名字也被用作主机名.同一Pod的容器可以共享
数据卷.

2 管理:从管理的角度来看,Pod比容器站在更高的层面,他简化了应用的部署和管理.Pod可
以自动处理主机托管,资源共享,协调复制和依赖管理等问题.

Pod的具体用例:

 内容管理系统,文件和数据的装载和本地缓存管理等.
 日志和检出点备份,压缩,轮换和快照.
 数据变更监控,日志末端数据读取,日志和监控适配器和事件打印.
 代理,桥接和适配器.
 控制器,管理器,配置编辑和更新.

---------------------------------------------

服务


kubernetes的服务是一系列Pod以及这些Pod的访问策略的抽象.

kubernetes中的Pod是具有时效性的,它会随着时间而变化.虽然每个Pod都有一个单独的IP
地址,但是该IP地址却不是静态不变的.例如,当系统触发RepliController对Pod进行备份
时,Pod的地址很可能发生变化.

kubernetes服务也叫微服务(micro-service),它用于定义一系列Pod的逻辑关系以及它们
的访问规则.服务的目标是为了隔绝前端和后端的耦合性,让前端透明地使用该项服务,而
不需要知道该项服务具体由哪些后台机器提供.kubernetes会为一个服务(即kubectl)分配
IP地址和端口,该IP和端口并不是真实的地址和端口,而是一个虚拟IP,当前端通过该地址
和端口访问服务时,服务代理会将请求重定向到合适的后端机器.


1 定义服务

kubernetes中的服务是一个REST(Representational State Transfer,表述性状态转义)对
象.

一个服务定义的例子:

{
	"id":"myapp",
	"selector": {
		"app":"Myapp"
	},
	"containerPort":9376,
	"protocal":"TCP",
	"port":8765
}
该示例定义了一个id为myapp的服务,他通过选择器选择那些带有app=MyApp标签的Pod作为
服务的提供者.所有被选择的Pod都将9376端口暴露,用于监听该项服务的请求.前端客户可
以通过$MYAPP_SERVICE_PORT和$MYAPP_SERVICE_HOST来访问该项服务.

2 工作原理

kubernetes中,每个节点都运行着一个服务代理(service proxy),他监控来自kubernetes
主控节点的消息,主控节点会向其传递诸如添加和删除服务以及服务的端点列表等信息.
服务代理维护着一个映射表,表中每一项是服务和该服务的提供者列表的映射关系,服务代
理还会为每一个服务在本地开放一个端口,当节点需要使用某项服务时,将请求发送至该端
口,然后由服务代理通过某种策略(例如轮换策略)安排服务的具体提供节点.

当一个Pod加入到kubernetes集群中时,主控点会在他上面为每一个已经存在的服务分配一
系列环境变量.变量的命名形如SVCNAME_SERVICE_HOST,其中SVCNAME是服务名称的大写.

例如:
服务redis-master在端口6379上提供TCP服务,其虚拟IP地址为10.0.0.11,对应的环境变量
REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379
REDIS_MASTER_PORT=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
REDIS_MASTER_PORT_6379_TCP_PORT=6379
REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
这些环境变量主要说明服务的地址,端口和协议.需要注意的是,既然一个Pod加入到集群的
kubernetes时,会被设置这些跟服务相关的环境变量,这意味着一个Pod只能发现他加入之
前就已经存在的服务.

        +----------------+ +----------------+ +----------------+
        |    后端Pod     | |    后端Pod     | |    后端Pod     |
        |Labels:app=MyApp| |Labels:app=MyApp| |Labels:app=MyApp|
        |   Port:9376    | |   Port:9376    | |   Port:9376    |
        +----------------+ +----------------+ +----------------+
                 ^                  ^                  ^
                 |                  |                  |
                 -------------------|------------------|
                                    |
+-----------------+        +----------------+
|主控节点apiserver|------->|    服务代理    |
+-----------------+        +----------------+
                                    ^
                                    |
                                +-------+
                                |前端Pod|
                                +-------+
                    前端通过服务代理来访问后端提供的服务
                  (只有apiserver在主控节点,其它在服务节点)

在前端Pod加入到该kubernetes集群时,主控节点的apiserver会将MyApp服务的服务信息推
送给该Pod,这些信息包含服务及其对应的端点(Endpoint)列表.前端Pod需要使用后端Pod
提供的MyApp服务,他并不直接联系后端Pod,而是将请求发给本地的服务代理,服务代理会
将该服务请求分配给这三个后端Pod中的一个.服务可以动态地增加和删除提供服务的Pod,
而前端Pod感知不到这些细节的变化,除非是正在为他提供服务的Pod状态发生了改变.

3 冲突避免

kubernetes的一个设计理念就是不能随便让用户去承受服务的失败,特别是用户根本就没
有犯错的情况下.考虑以下服务端口冲突的问题:假如第一项服务选取了80端口作为服务端
口,那么其他服务就不能再选该端口作为服务端口了.为了避免这种冲突问题,kubernetes
不仅选择了为每一个服务分配端口,同时也配置了一个IP.这样每一给服务都拥有自己的IP
和端口,从而避免了服务端口冲突.

4 Portal

这里的IP是虚拟IP,他并不是一台特定机器的真实IP.用户访问某个服务,就是访问某个服
务的Portal.当请求投递到该Portal之后,该请求会根据规则重定向到某个特定的服务提供
者Pod.

                +----------------+ +----------------+ +----------------+
                |    后端Pod     | |    后端Pod     | |    后端Pod     |
                |Labels:app=MyApp| |Labels:app=MyApp| |Labels:app=MyApp|
                |   Port:9376    | |   Port:9376    | |   Port:9376    |
                +----------------+ +----------------+ +----------------+
                         ^                  ^                  ^
                         |                  |                  |
                         -------------------|------------------|
                   [1及时更新服务]          |   [5选取一个后端提供的服务]
+-----------------+  [的配置信息]  +----------------+
|主控节点apiserver|--------------->|    服务代理    |
+-----------------+                +----------------+
                                    |           ^
                   [2设置Portal规则]|           |[4重定向到服务的代理端口]
                                    | +----------+
                                    ->| iptables |
                                      +----------+
                                            ^
                                            |[3连接Portal(10.0.0.1:1234)]
                                        +-------+
                                        |前端Pod|
                                        +-------+
                                 服务代理响应服务的过程

每一个节点都会有一个服务代理,当节点加入到kubernetes集群中时,主控节点apiserver
程序会将服务的配置信息投递给服务代理(1),服务代理保存服务配置信息,并根据Portal
信息设置iptables的网络规则(2),这里我们假设Portal为10.0.0.1:1234.前端通过链接我
们的Portal来访问服务(3),iptables监听到该请求,将该请求重定向到配置好的代理端口
上(4),服务代理从该端口接过服务请求,然后根据策略选取一个后端Pod(5),最后由选中的
后端Pod来给前端Pod提供服务.

--------------------------------------

标签

标签(label)是一组附加在对象上的键值对.标签用来从一组对象中选取符合条件的对象.
标签的本质是附属在对象上的非系统属性类的元数据,即他不是名字,Id以及对象的硬件属
性,而是一些附加的键值对,这些键值对对对象本身没有什么影响,但对操作对象却很有用.

例子:

{
	"id":"redis-master",
	"kind":"Pod",
	"apiVersion":"v1beta1",
	"desiredState": {
		"manifest": {
			"version":"v1beta1",
			"id":"redis-master",
			"containers": [{
				"name":"master",
				"image":"dockerfile/redis",
				"cpu":100,
				"ports": [{
					"containerPort":6379,
					"hostPort":6379
				}]
			}]
		}
	},
	"labels":{
		"name":"redis-master"
	}
}

可以看到,除了id,kind等这些系统属性外,还有labels属性,他是这个Pod的标签,tde键值
对为"name":"redis-master".有了这个标签,我们就可以在部署服务时,通过标签来指定只
包含该标签的Pod才可以部署该服务.

例子:

{
	"id":"redis-master",
	"kind":"Service",
	"apiVersion":"v1beta1",
	"port":6379,
	"containerPort":6379,
	"selector":{
		"name":"redis-master"
	},
	"labels":{
		"name":"redis-master"
	}
}

这个redis-master服务通过selector来选择标签为"name":"redis-master"的Pod来部署服
务.需要使用该服务的应用又可以根据该标签来过滤服务.

==============================================================================
==============================================================================
